import React from 'react';
import { Document, Page, Text, View, Font, PDFDownloadLink, pdf } from '@react-pdf/renderer';
import { 
  ReportData, 
  ACPerformance, 
  AssemblyData, 
  ZoneData, 
  DetailedActivity, 
  ExecutiveSummary,
  ReportMetric,
  ACPerformanceSections,
  ACWithAssemblies,
  ACAssemblyRow,
  ZoneWisePerformanceSections,
  ZoneWithPerformanceSections
} from '../../models/reportTypes';
import { 
  PDF_STYLES, 
  FONT_CONFIG, 
  FILE_NAME_CONFIG,
  getPerformanceLevel,
  getPerformanceColor 
} from '../config/pdfConfig';

// Register custom fonts for Devanagari support
Font.register({
  family: FONT_CONFIG.family,
  fonts: [
    { src: FONT_CONFIG.sources.regular, fontWeight: 'normal' },
    { src: FONT_CONFIG.sources.bold, fontWeight: 'bold' },
  ],
});

// Performance color scheme is now imported from config

// PDF Styles
const styles = PDF_STYLES;

// --- Helpers: sanitize text for React-PDF ---
function normalizeText(input: string): string {
  let s = input
    // Replace en/em dashes with hyphen
    .replace(/[\u2012-\u2015]/g, '-')
    // Replace bullet with asterisk
    .replace(/\u2022/g, '*')
    // Replace non-breaking hyphen with hyphen
    .replace(/\u2011/g, '-')
    // Replace NBSP with regular space
    .replace(/\u00A0/g, ' ')
    // Replace smart quotes with ASCII
    .replace(/[\u2018\u2019]/g, "'")
    .replace(/[\u201C\u201D]/g, '"');
  // Remove surrogate pairs (most emoji)
  s = s.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '');
  // Remove zero-width and BOM characters
  s = s.replace(/[\u200B\u200C\u200D\u2060\uFEFF]/g, '');
  return s;
}

function safeNumber(val: any): number {
  const n = Number(val);
  return Number.isFinite(n) ? n : 0;
}

// Debug controls for Stage 5 isolation (optional limits; leave undefined to disable)
const PDF_DEBUG: { stage5MaxACPerBucket?: number; stage5MaxRowsPerAC?: number } = {
  // stage5MaxACPerBucket: 5,
  // stage5MaxRowsPerAC: 10,
};

const FALLBACK_FONT = 'Helvetica';

function analyzeTextForWeirdChars(label: string, val: any) {
  try {
    const s = safeText(val);
    const suspicious: Array<{ ch: string; code: string }> = [];
    for (const ch of s) {
      const codePoint = ch.codePointAt(0) ?? 0;
      // Flag common troublemakers and anything in control/format ranges
      const isSuspicious = (
        codePoint === 0x00a0 || // NBSP
        codePoint === 0x2011 || // NB hyphen
        codePoint === 0x2022 || // bullet
        (codePoint >= 0x200b && codePoint <= 0x200d) || // zero-width
        codePoint === 0x2060 || // word joiner
        codePoint === 0xfeff // BOM
      );
      if (isSuspicious) {
        suspicious.push({ ch, code: 'U+' + codePoint.toString(16).toUpperCase().padStart(4, '0') });
      }
    }
    if (suspicious.length > 0) {
      console.warn('[PDF Text Analyzer] Suspicious chars in', label, suspicious);
    }
  } catch (e) {
    console.warn('[PDF Text Analyzer] Failed to analyze', label, e);
  }
}

function safeText(val: any): string {
  if (val === null || val === undefined) return '';
  try {
    const s = String(val);
    return normalizeText(s);
  } catch {
    return '';
  }
}

function safeDate(val: any): string {
  try {
    const d = new Date(val);
    if (isNaN(d.getTime())) return new Date().toLocaleDateString();
    return d.toLocaleDateString();
  } catch {
    return new Date().toLocaleDateString();
  }
}

interface PDFReportProps {
  data: ReportData;
  // Optional debug stage gates rendering progressively to isolate crashes
  debugStage?: number; // 1: Header, 2: ExecSummary, 3: ZoneOverview, 4: SummaryStats, 5: PerformanceSection, 6: Footer
}

// Header Component
const ReportHeader: React.FC<{ data: ReportData }> = ({ data }) => {
  const title = safeText(data.header?.title);
  const generatedAt = safeDate(data.header?.generatedAt);
  const start = safeText(data.header?.dateRange?.startDate);
  const end = safeText(data.header?.dateRange?.endDate);
  const verticalLabel = data.header?.vertical === 'shakti-abhiyaan' ? 'Shakti Abhiyaan' : 'WTM-SLP';
  const generatedBy = safeText(data.header?.generatedBy);
  console.log('[ReportHeader]', { title, generatedAt, start, end, verticalLabel, generatedBy });
  return (
    <View>
      <Text style={styles.title}>{title}</Text>
      <View style={styles.headerInfo}>
        <View style={{ flex: 1 }}>
          <Text style={styles.headerItem}>Generated: {generatedAt}</Text>
          <Text style={styles.headerItem}>Period: {start} to {end}</Text>
        </View>
        <View style={{ flex: 1 }}>
          <Text style={styles.headerItem}>Vertical: {verticalLabel}</Text>
          <Text style={styles.headerItem}>Generated By: {generatedBy}</Text>
        </View>
      </View>
    </View>
  );
};

// Interface for flattened AC data
interface FlattenedACData {
  zoneIndex: number;
  zone: string;
  zonalIncharge: string;
  assembly: string;
  acName: string;
  acId: string;
  meetings: number;
  onboarded: number;
  slps: number;
  forms: number;
  videos: number;
  waGroups: number;
  performanceLevel?: string;
  // Attendance logic flags
  includeInColorGrading?: boolean;
  workStatus?: string;
  shouldBeRed?: boolean;
  isUnavailable?: boolean;
}

// Function to flatten hierarchical data into table format
const flattenDataForTable = (zones: ZoneData[]): FlattenedACData[] => {
  const tableData: FlattenedACData[] = [];
  
  // Sort zones alphabetically by name (zones should already be properly ordered from aggregation)
  // Using stable sort to preserve original ordering for zones with same name
  const sortedZones = [...zones].sort((a, b) => {
    return a.name.localeCompare(b.name);
  });
  
  sortedZones.forEach((zone, zoneIndex) => {
    zone.assemblies.forEach(assembly => {
      assembly.acs.forEach(ac => {
        // Include phantom assemblies (no-ac-assigned) in the table
        tableData.push({
          zoneIndex: zoneIndex + 1, // Store zone index for display
          zone: zone.name,
          zonalIncharge: zone.inchargeName || 'N/A',
          assembly: assembly.name,
          acName: ac.id === 'no-ac-assigned' ? 'No AC Assigned' : ac.name,
          acId: ac.id, // Store AC ID for deduplication
          meetings: ac.metrics.meetings || 0,
          onboarded: ac.metrics.volunteers || 0,
          slps: ac.metrics.leaders || 0,
          forms: ac.metrics.forms || 0,
          videos: ac.metrics.videos || 0,
          waGroups: (ac.metrics.assemblyWaGroups || 0) + (ac.metrics.centralWaGroups || 0),
          performanceLevel: ac.id === 'no-ac-assigned' ? 'poor' : ac.performanceLevel,
          // Preserve attendance logic flags
          includeInColorGrading: (ac as any).includeInColorGrading,
          workStatus: (ac as any).workStatus,
          shouldBeRed: (ac as any).shouldBeRed,
          isUnavailable: (ac as any).isUnavailable
        });
        
        // Debug logging for flag preservation
        if ((ac as any).includeInColorGrading === false) {
          console.log(`[flattenDataForTable] *** FLAG PRESERVED *** AC ${ac.name} in ${assembly.name}: includeInColorGrading=false`);
        }
      });
    });
  });
  
  return tableData;
};

// Table Header Component
const TableHeader = () => (
  <View style={styles.tableHeaderRow}>
    <Text style={[styles.tableHeaderCell, { flex: 0.8 }]}>Zone</Text>
    <Text style={[styles.tableHeaderCell, { flex: 1.5 }]}>Zonal Incharge</Text>
    <Text style={[styles.tableHeaderCell, { flex: 1.5 }]}>Assembly</Text>
    <Text style={[styles.tableHeaderCell, { flex: 1.5 }]}>AC Name</Text>
    <Text style={styles.tableHeaderCell}>Meetings</Text>
    <Text style={styles.tableHeaderCell}>Onboarded</Text>
    <Text style={styles.tableHeaderCell}>SLPs</Text>
    <Text style={styles.tableHeaderCell}>Forms</Text>
    <Text style={styles.tableHeaderCell}>Videos</Text>
    <Text style={styles.tableHeaderCell}>WA Groups</Text>
  </View>
);

// Table Row Component with performance-based color coding
const TableRow = ({ data, index }: { data: FlattenedACData; index: number }) => {
  // Determine row style based on performance level
  const getRowStyle = () => {
    if (data.acId === 'no-ac-assigned') {
      // Phantom assemblies get neutral styling
      return [styles.tableRow, { backgroundColor: index % 2 === 0 ? '#ffffff' : '#f9fafb' }];
    }
    
    // Debug logging for includeInColorGrading flag
    console.log(`[TableRow] AC: ${data.acName}, Assembly: ${(data as any).assembly}, includeInColorGrading: ${(data as any).includeInColorGrading}, workStatus: ${(data as any).workStatus}`);
    
    // Check if AC should be included in color grading first
    if ((data as any).includeInColorGrading === false) {
      console.log(`[TableRow] Excluding AC ${data.acName} from color grading - showing white background`);
      // AC worked in different assembly - show data but no color grading (white background)
      return [styles.tableRow, { backgroundColor: index % 2 === 0 ? '#ffffff' : '#f9fafb' }];
    }
    
    // Apply performance-based color coding for ACs included in grading
    const meetings = Number(data.meetings) || 0;
    
    // Check if AC should be forced RED regardless of meeting count
    if ((data as any).shouldBeRed) {
      return [styles.tableRowPoor];
    }
    
    // Standard performance-based coloring
    if (meetings >= 7) {
      return [styles.tableRowHigh];
    } else if (meetings >= 5) {
      return [styles.tableRowModerate];
    } else {
      return [styles.tableRowPoor];
    }
  };
  
  // Determine cell style for metrics (highlight if > 0)
  const getMetricCellStyle = (value: any) => {
    const numValue = Number(value) || 0;
    if (data.acId === 'no-ac-assigned') {
      return styles.tableCellDim;
    }
    return numValue > 0 ? styles.tableCellHighlight : styles.tableCell;
  };
  
  return (
    <View style={getRowStyle()}>
      <Text style={[styles.tableCell, { flex: 0.8 }]}>Zone - {data.zoneIndex}</Text>
      <Text style={[styles.tableCell, { flex: 1.5 }]}>{data.zonalIncharge}</Text>
      <Text style={[styles.tableCell, { flex: 1.5 }]}>{data.assembly}</Text>
      <Text style={[styles.tableCell, { flex: 1.5 }]}>{data.acName}</Text>
      <Text style={getMetricCellStyle(data.meetings)}>{data.meetings}</Text>
      <Text style={getMetricCellStyle(data.onboarded)}>{data.onboarded}</Text>
      <Text style={getMetricCellStyle(data.slps)}>{data.slps}</Text>
      <Text style={getMetricCellStyle(data.forms)}>{data.forms}</Text>
      <Text style={getMetricCellStyle(data.videos)}>{data.videos}</Text>
      <Text style={getMetricCellStyle(data.waGroups)}>{data.waGroups}</Text>
    </View>
  );
};

/**
 * AC Performance Section Component - New AC-wise Layout
 */
interface ACPerformanceSectionProps {
  sections: ACPerformanceSections;
}

const ACPerformanceSection: React.FC<ACPerformanceSectionProps> = ({ sections }) => {
  return (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>AC Performance Report</Text>
      
      {/* Green Zone - Always show */}
      <ACPerformanceZone 
        title="High Performance Zone (Green)" 
        acs={sections.greenZone} 
        zoneColor="green" 
      />
      
      {/* Orange Zone - Always show */}
      <ACPerformanceZone 
        title="Moderate Performance Zone (Orange)" 
        acs={sections.orangeZone} 
        zoneColor="orange" 
      />
      
      {/* Red Zone - Always show */}
      <ACPerformanceZone 
        title="Poor Performance Zone (Red)" 
        acs={sections.redZone} 
        zoneColor="red" 
      />
      
      {/* Unavailable Zone - Always show */}
      <ACPerformanceZone 
        title="Unavailable ACs" 
        acs={sections.unavailable} 
        zoneColor="unavailable" 
      />
    </View>
  );
};

/**
 * AC Performance Zone Component
 */
interface ACPerformanceZoneProps {
  title: string;
  acs: ACWithAssemblies[];
  zoneColor: 'green' | 'orange' | 'red' | 'unavailable';
}

const ACPerformanceZone: React.FC<ACPerformanceZoneProps> = ({ title, acs, zoneColor }) => {
  const getTitleStyle = () => {
    const baseStyle = { ...styles.performanceSectionTitle };
    switch (zoneColor) {
      case 'green':
        return { ...baseStyle, ...styles.greenSectionTitle };
      case 'orange':
        return { ...baseStyle, ...styles.orangeSectionTitle };
      case 'red':
        return { ...baseStyle, ...styles.redSectionTitle };
      case 'unavailable':
        return { ...baseStyle, ...styles.unavailableSectionTitle };
      default:
        return baseStyle;
    }
  };

  return (
    <View style={styles.performanceSectionContainer}>
      <Text style={getTitleStyle()}>{title}</Text>
      {acs.length > 0 ? (
        acs.map((ac, index) => (
          // Use composite key to avoid duplicate keys when placeholder ACs like 'no-ac-assigned' repeat
          <ACWithAssembliesComponent key={`${ac.acId}-${index}`} ac={ac} />
        ))
      ) : (
        <View style={{ padding: 15, alignItems: 'center' }}>
          <Text style={{ fontSize: 10, color: '#6b7280' }}>
            No ACs in this performance zone
          </Text>
        </View>
      )}
    </View>
  );
};

/**
 * AC With Assemblies Component
 */
interface ACWithAssembliesComponentProps {
  ac: ACWithAssemblies;
}

const ACWithAssembliesComponent: React.FC<ACWithAssembliesComponentProps> = ({ ac }) => {
  const headerAcName = safeText(ac.acName);
  const headerZoneName = safeText(ac.zoneName);
  const assemblies = Array.isArray(ac.assemblies) ? ac.assemblies : [];
  const rowsToRender = typeof PDF_DEBUG.stage5MaxRowsPerAC === 'number'
    ? assemblies.slice(0, PDF_DEBUG.stage5MaxRowsPerAC)
    : assemblies;
  console.log('[ACWithAssemblies] Header', {
    acId: ac.acId,
    acName: headerAcName,
    zoneNumber: ac.zoneNumber,
    zoneName: headerZoneName,
    assembliesCount: assemblies.length,
    rowsToRender: rowsToRender.length,
  });
  return (
    <View wrap={false} style={{ marginBottom: 8 }}>
      {/* AC Header */}
      <View style={styles.acHeaderContainer}>
        <Text style={[styles.acHeaderText, { fontFamily: FALLBACK_FONT }]}>{`${headerAcName} - Zone ${ac.zoneNumber} (${headerZoneName})`}</Text>
        <Text style={[styles.acSubHeaderText, { fontFamily: FALLBACK_FONT }] }>
          {`Total Assemblies: ${safeNumber(ac.totalAssemblies)} | Worked in: ${safeNumber(ac.workedAssemblies)}`}
        </Text>
      </View>
      
      {/* Assembly Table */}
      <View style={styles.acAssemblyTableContainer}>
        {/* Table Header */}
        <View style={{ ...styles.acAssemblyRow, backgroundColor: '#f3f4f6', fontWeight: 'bold' }}>
          <Text style={{ ...styles.tableCell, width: '24%', fontFamily: FALLBACK_FONT }}>Assembly</Text>
          <Text style={{ ...styles.tableCell, width: '13%', fontFamily: FALLBACK_FONT }}>Meetings</Text>
          <Text style={{ ...styles.tableCell, width: '13%', fontFamily: FALLBACK_FONT }}>Onboarded</Text>
          <Text style={{ ...styles.tableCell, width: '12%', fontFamily: FALLBACK_FONT }}>SLPs</Text>
          <Text style={{ ...styles.tableCell, width: '12%', fontFamily: FALLBACK_FONT }}>Forms</Text>
          <Text style={{ ...styles.tableCell, width: '12%', fontFamily: FALLBACK_FONT }}>Videos</Text>
          <Text style={{ ...styles.tableCell, width: '14%', fontFamily: FALLBACK_FONT }}>WA Groups</Text>
        </View>
        
        {/* Assembly Rows */}
        {rowsToRender.map((assembly, index) => {
          try {
            const aName = safeText(assembly?.assembly);
            const metricsLog = {
              meetings: safeNumber((assembly as any)?.meetings),
              onboarded: safeNumber((assembly as any)?.onboarded),
              slps: safeNumber((assembly as any)?.slps),
              forms: safeNumber((assembly as any)?.forms),
              videos: safeNumber((assembly as any)?.videos),
              waGroups: safeNumber((assembly as any)?.waGroups),
              rowColor: (assembly as any)?.rowColor,
            };
            console.log('[ACWithAssemblies] Row', { index, assembly: aName, ...metricsLog });
            analyzeTextForWeirdChars('assembly', aName);
            return (
              <ACAssemblyRowComponent key={`${ac.acId}-${aName}-${index}`} assembly={assembly} />
            );
          } catch (e) {
            console.error('[ACWithAssemblies] Failed row', index, assembly);
            throw e;
          }
        })}
      </View>
    </View>
  );
};

/**
 * AC Assembly Row Component
 */
interface ACAssemblyRowComponentProps {
  assembly: ACAssemblyRow;
}

const ACAssemblyRowComponent: React.FC<ACAssemblyRowComponentProps> = ({ assembly }) => {
  // Determine row background color
  const getRowStyle = () => {
    const baseStyle = styles.acAssemblyRow;
    switch (assembly?.rowColor) {
      case 'high':
        return { ...baseStyle, ...styles.acAssemblyRowHigh };
      case 'moderate':
        return { ...baseStyle, ...styles.acAssemblyRowModerate };
      case 'poor':
        return { ...baseStyle, ...styles.acAssemblyRowPoor };
      case 'white':
      default:
        return { ...baseStyle, ...styles.acAssemblyRowWhite };
    }
  };

  return (
    <View style={getRowStyle()}>
      <Text style={{ ...styles.tableCell, width: '24%', fontFamily: FALLBACK_FONT }}>{safeText((assembly as any)?.assembly)}</Text>
      <Text style={{ ...styles.tableCell, width: '13%', fontFamily: FALLBACK_FONT }}>{safeNumber((assembly as any)?.meetings)}</Text>
      <Text style={{ ...styles.tableCell, width: '13%', fontFamily: FALLBACK_FONT }}>{safeNumber((assembly as any)?.onboarded)}</Text>
      <Text style={{ ...styles.tableCell, width: '12%', fontFamily: FALLBACK_FONT }}>{safeNumber((assembly as any)?.slps)}</Text>
      <Text style={{ ...styles.tableCell, width: '12%', fontFamily: FALLBACK_FONT }}>{safeNumber((assembly as any)?.forms)}</Text>
      <Text style={{ ...styles.tableCell, width: '12%', fontFamily: FALLBACK_FONT }}>{safeNumber((assembly as any)?.videos)}</Text>
      <Text style={{ ...styles.tableCell, width: '14%', fontFamily: FALLBACK_FONT }}>{safeNumber((assembly as any)?.waGroups)}</Text>
    </View>
  );
};

// Chunked AC Performance Table to prevent memory issues
const ACTable = ({ zones }: { zones: ZoneData[] }) => {
  try {
    console.log('[ACTable] Processing zones for table generation:', {
      zonesLength: zones.length,
      zonesType: typeof zones,
      isArray: Array.isArray(zones)
    });

    const tableData = flattenDataForTable(zones);
    console.log('[ACTable] Flattened table data:', {
      length: tableData.length,
      type: typeof tableData,
      isArray: Array.isArray(tableData),
      firstFewRows: tableData.slice(0, 3).map(row => ({
        zone: row.zone,
        assembly: row.assembly,
        acName: row.acName,
        meetings: row.meetings
      })),
      lastFewRows: tableData.slice(-3).map(row => ({
        zone: row.zone,
        assembly: row.assembly,
        acName: row.acName,
        meetings: row.meetings
      }))
    });
    
    // Calculate unique real ACs (exclude phantom entries and deduplicate)
    const uniqueRealACs = new Set(
      tableData
        .filter(row => row.acId !== 'no-ac-assigned')
        .map(row => row.acId)
    ).size;
    
    const MAX_ROWS_PER_CHUNK = 15; // Smaller chunks for better rendering
    const chunks = [];
    
    // Split data into chunks if too large
    if (tableData.length > MAX_ROWS_PER_CHUNK) {
      console.log(`[ACTable] Large dataset (${tableData.length} rows). Splitting into chunks of ${MAX_ROWS_PER_CHUNK}.`);
      
      for (let i = 0; i < tableData.length; i += MAX_ROWS_PER_CHUNK) {
        const chunk = tableData.slice(i, i + MAX_ROWS_PER_CHUNK);
        chunks.push(chunk);
        console.log(`[ACTable] Chunk ${chunks.length}: ${chunk.length} rows, first AC: ${chunk[0]?.acName}`);
      }
    } else {
      chunks.push(tableData);
    }
    
    console.log('[ACTable] Rendering', chunks.length, 'table chunks with total', tableData.length, 'rows');
    
    return (
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>AC Performance Report</Text>
        
        {/* Single continuous table with all chunks rendered seamlessly */}
        <View style={styles.table}>
          <TableHeader />
          {chunks.map((chunk, chunkIndex) => 
            chunk.map((row, index) => {
              const globalIndex = chunkIndex * MAX_ROWS_PER_CHUNK + index;
              try {
                return (
                  <TableRow 
                    key={`row-${globalIndex}-${row.acId}`} 
                    data={row} 
                    index={globalIndex} 
                  />
                );
              } catch (rowError) {
                console.error(`[ACTable] ❌ Error rendering row ${globalIndex}:`, rowError);
                console.error('[ACTable] Row data:', JSON.stringify(row, null, 2));
                throw rowError;
              }
            })
          )}
        </View>
        
        <View style={styles.tableSummary}>
          <Text style={styles.summaryText}>Total ACs: {uniqueRealACs}</Text>
          <Text style={[styles.summaryText, { marginLeft: 20 }]}>Total Rows: {tableData.length}</Text>
          {chunks.length > 1 ? (
            <Text style={[styles.summaryText, { marginLeft: 20 }]}>Sections: {chunks.length}</Text>
          ) : null}
        </View>
      </View>
    );
  } catch (error) {
    console.error('=== ACTABLE ERROR ===');
    console.error('[ACTable] ❌ Error in ACTable component:', error);
    console.error('[ACTable] Zones data causing error:', JSON.stringify(zones, null, 2));
    throw error;
  }
};

// Summary Statistics Component
const SummaryStatistics: React.FC<{ zones: ZoneData[] }> = ({ zones }) => {
  // Calculate totals from zones
  let totalMeetings = 0;
  let totalOnboarded = 0;
  let totalSLPs = 0;
  let totalForms = 0;
  let totalVideos = 0;
  let totalWAGroups = 0;
  let totalACs = 0;
  
  zones.forEach(zone => {
    zone.assemblies.forEach(assembly => {
      assembly.acs.forEach(ac => {
        if (ac.id !== 'no-ac-assigned') {
          totalACs++;
          totalMeetings += ac.metrics.meetings || 0;
          totalOnboarded += ac.metrics.volunteers || 0;
          totalSLPs += ac.metrics.slps || 0;
          totalForms += ac.metrics.forms || 0;
          totalVideos += ac.metrics.videos || 0;
          totalWAGroups += (ac.metrics.assemblyWaGroups || 0) + (ac.metrics.centralWaGroups || 0);
        }
      });
    });
  });
  
  return (
    <View style={styles.summaryBox}>
      <Text style={styles.summaryTitle}>Summary Statistics</Text>
      <View style={styles.metricsGrid}>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total Meetings</Text>
          <Text style={styles.metricValue}>{totalMeetings}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total Onboarded</Text>
          <Text style={styles.metricValue}>{totalOnboarded}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total SLPs</Text>
          <Text style={styles.metricValue}>{totalSLPs}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total Forms</Text>
          <Text style={styles.metricValue}>{totalForms}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total Videos</Text>
          <Text style={styles.metricValue}>{totalVideos}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total WA Groups</Text>
          <Text style={styles.metricValue}>{totalWAGroups}</Text>
        </View>
      </View>
    </View>
  );
};

// Detailed Activities Component (if included)
const DetailedActivitiesSection: React.FC<{ activities: DetailedActivity[] }> = ({ activities }) => {
  if (!activities || activities.length === 0) return null;
  
  return (
    <View style={styles.indentLevel1}>
      <Text style={styles.subsectionTitle}>Recent Activities (Sample)</Text>
      {activities.slice(0, 5).map((activity, idx) => {
        console.log('[DetailedActivities] item', idx, activity);
        return (
          <View key={idx} style={styles.activityItem}>
            <Text style={styles.boldText}>{safeText(activity?.type)} - {safeText(activity?.coordinatorName)}</Text>
            <Text>Assembly: {safeText(activity?.assembly)}</Text>
            <Text>Date: {safeText(activity?.date)}</Text>
            {activity?.description ? <Text>{safeText(activity.description)}</Text> : null}
          </View>
        );
      })}
    </View>
  );
};

/**
 * Zone-wise Performance Section Component - New Zone-wise Layout
 */
interface ZoneWisePerformanceSectionProps {
  sections: ZoneWisePerformanceSections;
}

const ZoneWisePerformanceSection: React.FC<ZoneWisePerformanceSectionProps> = ({ sections }) => {
  // Defensive guard: ensure sections and zones array exist
  const zones = Array.isArray(sections?.zones) ? sections.zones : [];
  
  if (zones.length === 0) {
    console.warn('[ZoneWisePerformanceSection] No zones provided for zone-wise report');
    return (
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Zone-wise AC Performance Report</Text>
        <View style={{ padding: 20, alignItems: 'center', backgroundColor: '#f9fafb' }}>
          <Text style={{ fontSize: 10, color: '#6b7280' }}>
            No zone data available for this report.
          </Text>
        </View>
      </View>
    );
  }
  
  // Stage 5 zone summary-level logs
  zones.forEach((zone) => {
    try {
      const g = zone.acPerformanceSections?.greenZone?.length ?? 0;
      const o = zone.acPerformanceSections?.orangeZone?.length ?? 0;
      const r = zone.acPerformanceSections?.redZone?.length ?? 0;
      const u = zone.acPerformanceSections?.unavailable?.length ?? 0;
      console.log('[ZoneWisePerformanceSection] Zone summary', {
        zoneNumber: zone.zoneNumber,
        zoneName: safeText(zone.zoneName),
        counts: { green: g, orange: o, red: r, unavailable: u },
      });
      analyzeTextForWeirdChars('zoneName', zone.zoneName);
    } catch (e) {
      console.warn('[ZoneWisePerformanceSection] Failed zone summary log', e);
    }
  });

  return (
    <View style={styles.section}>
      <Text style={[styles.sectionTitle, { fontFamily: FALLBACK_FONT }]}>Zone-wise AC Performance Report</Text>
      
      {zones.map((zone, index) => (
        <ZonePerformanceComponent key={`zone-${zone.zoneNumber}-${index}`} zone={zone} />
      ))}
    </View>
  );
};

/**
 * Zone-specific AC Performance Section Component
 * Designed specifically for zone-wise layout without nesting issues
 */
interface ZoneACPerformanceSectionProps {
  title: string;
  acs: ACWithAssemblies[];
  zoneColor: 'green' | 'orange' | 'red' | 'unavailable';
}

const ZoneACPerformanceSection: React.FC<ZoneACPerformanceSectionProps> = ({ title, acs, zoneColor }) => {
  const getTitleStyle = () => {
    const baseStyle = { ...styles.performanceSectionTitle, marginTop: 5, marginBottom: 5 };
    switch (zoneColor) {
      case 'green':
        return { ...baseStyle, ...styles.greenSectionTitle };
      case 'orange':
        return { ...baseStyle, ...styles.orangeSectionTitle };
      case 'red':
        return { ...baseStyle, ...styles.redSectionTitle };
      case 'unavailable':
        return { ...baseStyle, ...styles.unavailableSectionTitle };
      default:
        return baseStyle;
    }
  };

  const totalAcs = acs.length;
  if (totalAcs === 0) {
    return (
      <View style={{ marginBottom: 10 }}>
        <Text style={getTitleStyle()}>{title}</Text>
        <View style={{ padding: 10, alignItems: 'center', backgroundColor: '#f9fafb' }}>
          <Text style={{ fontSize: 9, color: '#6b7280' }}>
            No ACs in this performance zone
          </Text>
        </View>
      </View>
    );
  }

  console.log('[ZoneACPerformanceSection] Rendering bucket', { title, zoneColor, totalAcs });
  const renderAcs = typeof PDF_DEBUG.stage5MaxACPerBucket === 'number'
    ? acs.slice(0, PDF_DEBUG.stage5MaxACPerBucket)
    : acs;

  return (
    <View style={{ marginBottom: 10 }}>
      <Text style={[getTitleStyle(), { fontFamily: FALLBACK_FONT }]}>{title}</Text>
      {renderAcs.map((ac, index) => {
        try {
          console.log('[ZoneACPerformanceSection] AC', {
            index,
            acId: ac.acId,
            acName: safeText(ac.acName),
            zoneName: safeText(ac.zoneName),
            totalAssemblies: ac.totalAssemblies,
            workedAssemblies: ac.workedAssemblies,
          });
          analyzeTextForWeirdChars('acName', ac.acName);
          analyzeTextForWeirdChars('zoneName', ac.zoneName);
          // Use composite key to avoid duplicate keys when placeholder ACs like 'no-ac-assigned' repeat
          return <ACWithAssembliesComponent key={`${ac.acId}-${index}`} ac={ac} />;
        } catch (e) {
          console.error('[ZoneACPerformanceSection] Failed rendering AC', index, ac);
          throw e;
        }
      })}
    </View>
  );
};

/**
 * Individual Zone Performance Component
 */
interface ZonePerformanceComponentProps {
  zone: ZoneWithPerformanceSections;
}

const ZonePerformanceComponent: React.FC<ZonePerformanceComponentProps> = ({ zone }) => {
  // Build safe header text for React-PDF: avoid boolean/null children inside <Text>
  const zoneInchargeStr = zone.zoneIncharge && zone.zoneIncharge !== 'N/A' ? ` (${zone.zoneIncharge})` : '';
  const zoneHeaderText = `Zone ${zone.zoneNumber}: ${zone.zoneName}${zoneInchargeStr}`;

  return (
    <View style={styles.zoneContainer}>
      <Text style={styles.zoneTitle}>{zoneHeaderText}</Text>
      
      {/* Green Zone within this geographical zone */}
      <ZoneACPerformanceSection 
        title="High Performance ACs (Green)" 
        acs={zone.acPerformanceSections.greenZone} 
        zoneColor="green" 
      />
      
      {/* Orange Zone within this geographical zone */}
      <ZoneACPerformanceSection 
        title="Moderate Performance ACs (Orange)" 
        acs={zone.acPerformanceSections.orangeZone} 
        zoneColor="orange" 
      />
      
      {/* Red Zone within this geographical zone */}
      <ZoneACPerformanceSection 
        title="Poor Performance ACs (Red)" 
        acs={zone.acPerformanceSections.redZone} 
        zoneColor="red" 
      />
      
      {/* Unavailable ACs within this geographical zone */}
      <ZoneACPerformanceSection 
        title="Unavailable ACs" 
        acs={zone.acPerformanceSections.unavailable} 
        zoneColor="unavailable" 
      />
    </View>
  );
};

// Enhanced Error Boundary Component with corrected AC counting
const ZoneWiseSummary = ({ zones }: { zones: ZoneData[] }) => {
  // Calculate corrected metrics for each zone
  const zoneMetrics = zones.map(zone => {
    // Get unique real AC IDs (exclude phantom entries)
    const uniqueACs = new Set<string>();
    let activeCount = 0;
    
    zone.assemblies.forEach(assembly => {
      assembly.acs.forEach(ac => {
        if (ac.id !== 'no-ac-assigned') {
          uniqueACs.add(ac.id);
          // Count as active if meetings >= 7
          if (Number(ac.metrics.meetings) >= 7) {
            activeCount++;
          }
        }
      });
    });
    
    return {
      name: zone.name,
      totalAssemblies: zone.totalAssemblies,
      totalACs: uniqueACs.size, // Deduplicated count
      activeACs: activeCount
    };
  });
  
  return (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>Zone-wise Overview</Text>
      <View style={styles.summaryTable}>
        <View style={styles.summaryHeader}>
          <Text style={styles.summaryHeaderText}>Zone</Text>
          <Text style={styles.summaryHeaderText}>Assemblies</Text>
          <Text style={styles.summaryHeaderText}>Total ACs</Text>
          <Text style={styles.summaryHeaderText}>Active ACs</Text>
        </View>
        {zoneMetrics.map((zone, index) => (
          <View key={index} style={styles.summaryRow}>
            <Text style={styles.summaryCell}>{zone.name}</Text>
            <Text style={styles.summaryCell}>{zone.totalAssemblies}</Text>
            <Text style={styles.summaryCell}>{zone.totalACs}</Text>
            <Text style={styles.summaryCell}>{zone.activeACs}</Text>
          </View>
        ))}
      </View>
    </View>
  );
};

// Executive Summary Component
const ExecutiveSummarySection: React.FC<{ summary: ExecutiveSummary }> = ({ summary }) => (
  <View>
    <Text style={styles.subtitle}>Executive Summary</Text>
    <View style={styles.row}>
      <View style={styles.column}>
        <Text style={styles.boldText}>Total Zones: {summary.totalZones}</Text>
        <Text style={styles.boldText}>Total Assemblies: {summary.totalAssemblies}</Text>
      </View>
      <View style={styles.column}>
        <Text style={styles.boldText}>Total ACs: {summary.totalACs}</Text>
        <Text style={styles.boldText}>Total SLPs: {summary.totalSLPs}</Text>
      </View>
    </View>
    <View style={styles.row}>
      <View style={styles.column}>
        <Text style={styles.text}>Active ACs: {summary.activeACs}</Text>
        <Text style={styles.text}>Active SLPs: {summary.activeSLPs}</Text>
      </View>
      <View style={styles.column}>
        <Text style={styles.text}>High Performance: {summary.performanceSummary?.high ?? 0} ACs</Text>
        <Text style={styles.text}>Moderate: {summary.performanceSummary?.moderate ?? 0} ACs</Text>
        <Text style={styles.text}>Needs Attention: {summary.performanceSummary?.poor ?? 0} ACs</Text>
      </View>
    </View>
    <View style={styles.metricsGrid}>
      {(Array.isArray(summary.keyMetrics) ? summary.keyMetrics : []).map((metric: ReportMetric, idx: number) => (
        <View key={idx} style={styles.metricBox}>
          <Text style={styles.metricLabel}>{metric.name}</Text>
          <Text style={styles.metricValue}>{metric.value}</Text>
        </View>
      ))}
    </View>
  </View>
);

// Error Boundary Wrapper Component
const SafeComponent: React.FC<{ children: React.ReactNode; componentName: string; data?: any }> = ({ children, componentName, data }) => {
  try {
    console.log(`[SafeComponent] Rendering ${componentName}`);
    return <>{children}</>;
  } catch (error) {
    console.error(`=== ERROR in ${componentName} ===`);
    console.error(`[SafeComponent] ❌ Error in ${componentName}:`, error);
    if (data) {
      console.error(`[SafeComponent] Data causing error in ${componentName}:`, JSON.stringify(data, null, 2));
    }
    throw error; // Re-throw to trigger main error handler
  }
};

// Main PDF Document Component - Table Based Layout
const PDFReport: React.FC<PDFReportProps> = ({ data, debugStage }) => {
  try {
    console.log('[PDFReport] Starting PDF component render');
    const shouldRender = (stage: number) => !debugStage || debugStage >= stage;
    
    // Precompute stage blocks to allow side-effect logs outside JSX
    const headerBlock = (() => {
      if (!shouldRender(1)) return null;
      console.log('[PDFReport] Stage 1: Header');
      return (
        <SafeComponent componentName="ReportHeader" data={data.header}>
          <ReportHeader data={data} />
        </SafeComponent>
      );
    })();

    const execSummaryBlock = (() => {
      if (!shouldRender(2)) return null;
      console.log('[PDFReport] Stage 2: Executive Summary');
      return (
        <SafeComponent componentName="ExecutiveSummarySection" data={data.summary}>
          <ExecutiveSummarySection summary={data.summary} />
        </SafeComponent>
      );
    })();

    const zoneSummaryBlock = (() => {
      if (!(shouldRender(3) && data.zones && data.zones.length > 0)) return null;
      console.log('[PDFReport] Stage 3: Zone-wise Summary, zones:', data.zones?.length);
      return (
        <SafeComponent componentName="ZoneWiseSummary" data={data.zones}>
          <ZoneWiseSummary zones={data.zones} />
        </SafeComponent>
      );
    })();

    const summaryStatsBlock = (() => {
      if (!(shouldRender(4) && data.zones && data.zones.length > 0)) return null;
      console.log('[PDFReport] Stage 4: Summary Statistics');
      return (
        <SafeComponent componentName="SummaryStatistics" data={data.zones}>
          <SummaryStatistics zones={data.zones} />
        </SafeComponent>
      );
    })();

    const performanceBlock = (() => {
      if (!shouldRender(5)) return null;
      if ((data as any).zoneWisePerformanceSections) {
        console.log('[PDFReport] Stage 5: Zone-wise Performance Section');
        return (
          <SafeComponent componentName="ZoneWisePerformanceSection" data={(data as any).zoneWisePerformanceSections}>
            <ZoneWisePerformanceSection sections={(data as any).zoneWisePerformanceSections} />
          </SafeComponent>
        );
      } else if (data.acPerformanceSections) {
        console.log('[PDFReport] Stage 5: AC-wise Performance Section');
        return (
          <SafeComponent componentName="ACPerformanceSection" data={data.acPerformanceSections}>
            <ACPerformanceSection sections={data.acPerformanceSections} />
          </SafeComponent>
        );
      } else if (data.zones && data.zones.length > 0) {
        console.log('[PDFReport] Stage 5: ACTable Fallback');
        return (
          <SafeComponent componentName="ACTable" data={data.zones}>
            <ACTable zones={data.zones} />
          </SafeComponent>
        );
      }
      return (
        <View style={{ padding: 20 }}>
          <Text style={styles.text}>No zone data available for report generation.</Text>
        </View>
      );
    })();

    const footerBlock = (() => {
      if (!shouldRender(6)) return null;
      console.log('[PDFReport] Stage 6: Footer');
      return (
        <SafeComponent componentName="Footer" data={data.header}>
          <Text style={[styles.footer, { fontSize: 7 }]}>
            {`Bihar Congress Dashboard - ${safeText(data.header?.title)} | Generated: ${safeDate(data.header?.generatedAt)}`}
          </Text>
        </SafeComponent>
      );
    })();

    return (
      <Document>
        <Page size="A4" style={styles.page} orientation="landscape">
          {headerBlock}
          {execSummaryBlock}
          {zoneSummaryBlock}
          {summaryStatsBlock}
          {performanceBlock}
          {footerBlock}
        </Page>
      </Document>
    );
  } catch (renderError) {
    console.error('=== PDF COMPONENT RENDER ERROR ===');
    console.error('[PDFReport] ❌ Error during component render:', renderError);
    console.error('[PDFReport] Complete data structure causing error:', JSON.stringify(data, null, 2));
    throw renderError;
  }
};

/**
 * Generate PDF blob from report data
 */
export async function generatePDFBlob(data: ReportData): Promise<Blob> {
  console.log('[generatePDFBlob] Starting PDF generation for:', data.header.title);
  
  try {
    // Calculate data sizes for analysis
    const totalAssemblies = data.zones.reduce((sum, zone) => sum + zone.assemblies.length, 0);
    const totalACs = data.zones.reduce((sum, zone) => 
      sum + zone.assemblies.reduce((acSum, assembly) => acSum + assembly.acs.length, 0), 0);
    
    console.log('[generatePDFBlob] 📊 DATA SIZE ANALYSIS:', {
      zones: data.zones.length,
      totalAssemblies,
      totalACs,
      keyMetrics: data.summary?.keyMetrics?.length || 0,
      estimatedTableRows: totalACs,
      dataStringSize: JSON.stringify(data).length,
      exceedsRecommendedSize: totalACs > 50 ? '⚠️  YES - May cause memory issues' : '✅ Within limits'
    });
    
    // Warn if data size is large
    if (totalACs > 100) {
      console.warn('⚠️  [generatePDFBlob] LARGE DATASET WARNING: ' + totalACs + ' ACs may exceed PDF rendering limits');
    }
    
    console.log('[generatePDFBlob] Attempting PDF generation...');
    const blob = await pdf(<PDFReport data={data} />).toBlob();
    console.log('[generatePDFBlob] ✅ PDF generated successfully, size:', blob.size);
    return blob;
  } catch (error) {
    console.error('=== PDF GENERATION ERROR CAUGHT ===');
    console.error('[generatePDFBlob] ❌ Error Type:', error instanceof Error ? error.name : 'Unknown');
    console.error('[generatePDFBlob] ❌ Error Message:', error instanceof Error ? error.message : String(error));
    
    // Progressive debug: try rendering incrementally to identify failing stage
    const stages = [1, 2, 3, 4, 5, 6];
    for (const stage of stages) {
      try {
        console.warn(`[generatePDFBlob] Progressive test: rendering up to stage ${stage}...`);
        await pdf(<PDFReport data={data} debugStage={stage} />).toBlob();
        console.warn(`[generatePDFBlob] Progressive stage ${stage} ✓ succeeded`);
      } catch (stageErr) {
        console.error(`[generatePDFBlob] Progressive stage ${stage} ✗ failed`, stageErr);
        break;
      }
    }

    // Check if it's an array length error
    if (error instanceof Error && error.message.includes('Invalid array length')) {
      const totalACs = data.zones.reduce((sum, zone) => 
        sum + zone.assemblies.reduce((acSum, assembly) => acSum + assembly.acs.length, 0), 0);
      
      console.error('=== ARRAY LENGTH ERROR - SIZE ANALYSIS ===');
      console.error('[generatePDFBlob] ❌ LIKELY CAUSE: Dataset too large for PDF rendering');
      console.error('[generatePDFBlob] Total ACs attempting to render:', totalACs);
      console.error('[generatePDFBlob] Total data size (bytes):', JSON.stringify(data).length);
      console.error('[generatePDFBlob] Recommendation: Implement data chunking or filtering');
      console.error('=== SOLUTION: Reduce data size or implement pagination ===');
    }
    
    throw error;
  }
}

/**
 * Generate and download PDF report
 */
export async function generateAndDownloadPDF(data: ReportData): Promise<void> {
  console.log('[generateAndDownloadPDF] Starting PDF generation and download');
  
  try {
    const blob = await generatePDFBlob(data);
    
    // Create download link
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    
    // Generate filename
    const timestamp = new Date().toISOString().slice(0, 10);
    const vertical = data.header.vertical === 'shakti-abhiyaan' ? 'ShaktiAbhiyaan' : 'WTMSLP';
    const dateRange = `${data.header.dateRange.startDate}_to_${data.header.dateRange.endDate}`.replace(/\//g, '-');
    link.download = `${vertical}_Report_${dateRange}_${timestamp}.pdf`;
    
    // Trigger download
    document.body.appendChild(link);
    link.click();
    
    // Cleanup
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    console.log('[generateAndDownloadPDF] PDF download initiated successfully');
  } catch (error) {
    console.error('[generateAndDownloadPDF] Error during PDF generation/download:', error);
    throw error;
  }
}
