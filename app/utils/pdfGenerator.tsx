import React from 'react';
import { Document, Page, Text, View, Font, PDFDownloadLink, pdf } from '@react-pdf/renderer';
import { 
  ReportData, 
  ACPerformance, 
  AssemblyData, 
  ZoneData, 
  DetailedActivity, 
  ExecutiveSummary,
  ReportMetric,
  ACPerformanceSections,
  ACWithAssemblies,
  ACAssemblyRow
} from '../../models/reportTypes';
import { 
  PDF_STYLES, 
  FONT_CONFIG, 
  FILE_NAME_CONFIG,
  getPerformanceLevel,
  getPerformanceColor 
} from '../config/pdfConfig';

// Register custom fonts for Devanagari support
Font.register({
  family: FONT_CONFIG.family,
  fonts: [
    { src: FONT_CONFIG.sources.regular, fontWeight: 'normal' },
    { src: FONT_CONFIG.sources.bold, fontWeight: 'bold' },
  ],
});

// Performance color scheme is now imported from config

// PDF Styles
const styles = PDF_STYLES;

interface PDFReportProps {
  data: ReportData;
}

// Header Component
const ReportHeader: React.FC<{ data: ReportData }> = ({ data }) => (
  <View>
    <Text style={styles.title}>{data.header.title}</Text>
    <View style={styles.headerInfo}>
      <View style={{ flex: 1 }}>
        <Text style={styles.headerItem}>Generated: {new Date(data.header.generatedAt).toLocaleDateString()}</Text>
        <Text style={styles.headerItem}>Period: {data.header.dateRange.startDate} to {data.header.dateRange.endDate}</Text>
      </View>
      <View style={{ flex: 1 }}>
        <Text style={styles.headerItem}>Vertical: {data.header.vertical === 'shakti-abhiyaan' ? 'Shakti Abhiyaan' : 'WTM-SLP'}</Text>
        <Text style={styles.headerItem}>Generated By: {data.header.generatedBy}</Text>
      </View>
    </View>
  </View>
);

// Interface for flattened AC data
interface FlattenedACData {
  zoneIndex: number;
  zone: string;
  zonalIncharge: string;
  assembly: string;
  acName: string;
  acId: string;
  meetings: number;
  onboarded: number;
  slps: number;
  forms: number;
  videos: number;
  waGroups: number;
  performanceLevel?: string;
  // Attendance logic flags
  includeInColorGrading?: boolean;
  workStatus?: string;
  shouldBeRed?: boolean;
  isUnavailable?: boolean;
}

// Function to flatten hierarchical data into table format
const flattenDataForTable = (zones: ZoneData[]): FlattenedACData[] => {
  const tableData: FlattenedACData[] = [];
  
  // Sort zones by extracting zone number
  const sortedZones = [...zones].sort((a, b) => {
    const getZoneNumber = (name: string) => {
      const match = name.match(/Zone\s+(\d+)/i);
      return match ? parseInt(match[1]) : 999;
    };
    return getZoneNumber(a.name) - getZoneNumber(b.name);
  });
  
  sortedZones.forEach((zone, zoneIndex) => {
    zone.assemblies.forEach(assembly => {
      assembly.acs.forEach(ac => {
        // Include phantom assemblies (no-ac-assigned) in the table
        tableData.push({
          zoneIndex: zoneIndex + 1, // Store zone index for display
          zone: zone.name,
          zonalIncharge: zone.inchargeName || 'N/A',
          assembly: assembly.name,
          acName: ac.id === 'no-ac-assigned' ? 'No AC Assigned' : ac.name,
          acId: ac.id, // Store AC ID for deduplication
          meetings: ac.metrics.meetings || 0,
          onboarded: ac.metrics.volunteers || 0,
          slps: ac.metrics.leaders || 0,
          forms: ac.metrics.forms || 0,
          videos: ac.metrics.videos || 0,
          waGroups: (ac.metrics.assemblyWaGroups || 0) + (ac.metrics.centralWaGroups || 0),
          performanceLevel: ac.id === 'no-ac-assigned' ? 'poor' : ac.performanceLevel,
          // Preserve attendance logic flags
          includeInColorGrading: (ac as any).includeInColorGrading,
          workStatus: (ac as any).workStatus,
          shouldBeRed: (ac as any).shouldBeRed,
          isUnavailable: (ac as any).isUnavailable
        });
        
        // Debug logging for flag preservation
        if ((ac as any).includeInColorGrading === false) {
          console.log(`[flattenDataForTable] *** FLAG PRESERVED *** AC ${ac.name} in ${assembly.name}: includeInColorGrading=false`);
        }
      });
    });
  });
  
  return tableData;
};

// Table Header Component
const TableHeader = () => (
  <View style={styles.tableHeaderRow}>
    <Text style={[styles.tableHeaderCell, { flex: 0.8 }]}>Zone</Text>
    <Text style={[styles.tableHeaderCell, { flex: 1.5 }]}>Zonal Incharge</Text>
    <Text style={[styles.tableHeaderCell, { flex: 1.5 }]}>Assembly</Text>
    <Text style={[styles.tableHeaderCell, { flex: 1.5 }]}>AC Name</Text>
    <Text style={styles.tableHeaderCell}>Meetings</Text>
    <Text style={styles.tableHeaderCell}>Onboarded</Text>
    <Text style={styles.tableHeaderCell}>SLPs</Text>
    <Text style={styles.tableHeaderCell}>Forms</Text>
    <Text style={styles.tableHeaderCell}>Videos</Text>
    <Text style={styles.tableHeaderCell}>WA Groups</Text>
  </View>
);

// Table Row Component with performance-based color coding
const TableRow = ({ data, index }: { data: FlattenedACData; index: number }) => {
  // Determine row style based on performance level
  const getRowStyle = () => {
    if (data.acId === 'no-ac-assigned') {
      // Phantom assemblies get neutral styling
      return [styles.tableRow, { backgroundColor: index % 2 === 0 ? '#ffffff' : '#f9fafb' }];
    }
    
    // Debug logging for includeInColorGrading flag
    console.log(`[TableRow] AC: ${data.acName}, Assembly: ${(data as any).assembly}, includeInColorGrading: ${(data as any).includeInColorGrading}, workStatus: ${(data as any).workStatus}`);
    
    // Check if AC should be included in color grading first
    if ((data as any).includeInColorGrading === false) {
      console.log(`[TableRow] Excluding AC ${data.acName} from color grading - showing white background`);
      // AC worked in different assembly - show data but no color grading (white background)
      return [styles.tableRow, { backgroundColor: index % 2 === 0 ? '#ffffff' : '#f9fafb' }];
    }
    
    // Apply performance-based color coding for ACs included in grading
    const meetings = Number(data.meetings) || 0;
    
    // Check if AC should be forced RED regardless of meeting count
    if ((data as any).shouldBeRed) {
      return [styles.tableRowPoor];
    }
    
    // Standard performance-based coloring
    if (meetings >= 7) {
      return [styles.tableRowHigh];
    } else if (meetings >= 5) {
      return [styles.tableRowModerate];
    } else {
      return [styles.tableRowPoor];
    }
  };
  
  // Determine cell style for metrics (highlight if > 0)
  const getMetricCellStyle = (value: any) => {
    const numValue = Number(value) || 0;
    if (data.acId === 'no-ac-assigned') {
      return styles.tableCellDim;
    }
    return numValue > 0 ? styles.tableCellHighlight : styles.tableCell;
  };
  
  return (
    <View style={getRowStyle()}>
      <Text style={[styles.tableCell, { flex: 0.8 }]}>Zone - {data.zoneIndex}</Text>
      <Text style={[styles.tableCell, { flex: 1.5 }]}>{data.zonalIncharge}</Text>
      <Text style={[styles.tableCell, { flex: 1.5 }]}>{data.assembly}</Text>
      <Text style={[styles.tableCell, { flex: 1.5 }]}>{data.acName}</Text>
      <Text style={getMetricCellStyle(data.meetings)}>{data.meetings}</Text>
      <Text style={getMetricCellStyle(data.onboarded)}>{data.onboarded}</Text>
      <Text style={getMetricCellStyle(data.slps)}>{data.slps}</Text>
      <Text style={getMetricCellStyle(data.forms)}>{data.forms}</Text>
      <Text style={getMetricCellStyle(data.videos)}>{data.videos}</Text>
      <Text style={getMetricCellStyle(data.waGroups)}>{data.waGroups}</Text>
    </View>
  );
};

/**
 * AC Performance Section Component - New AC-wise Layout
 */
interface ACPerformanceSectionProps {
  sections: ACPerformanceSections;
}

const ACPerformanceSection: React.FC<ACPerformanceSectionProps> = ({ sections }) => {
  return (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>AC Performance Report</Text>
      
      {/* Green Zone - Always show */}
      <ACPerformanceZone 
        title="High Performance Zone (Green)" 
        acs={sections.greenZone} 
        zoneColor="green" 
      />
      
      {/* Orange Zone - Always show */}
      <ACPerformanceZone 
        title="Moderate Performance Zone (Orange)" 
        acs={sections.orangeZone} 
        zoneColor="orange" 
      />
      
      {/* Red Zone - Always show */}
      <ACPerformanceZone 
        title="Poor Performance Zone (Red)" 
        acs={sections.redZone} 
        zoneColor="red" 
      />
      
      {/* Unavailable Zone - Always show */}
      <ACPerformanceZone 
        title="Unavailable ACs" 
        acs={sections.unavailable} 
        zoneColor="unavailable" 
      />
    </View>
  );
};

/**
 * AC Performance Zone Component
 */
interface ACPerformanceZoneProps {
  title: string;
  acs: ACWithAssemblies[];
  zoneColor: 'green' | 'orange' | 'red' | 'unavailable';
}

const ACPerformanceZone: React.FC<ACPerformanceZoneProps> = ({ title, acs, zoneColor }) => {
  const getTitleStyle = () => {
    const baseStyle = { ...styles.performanceSectionTitle };
    switch (zoneColor) {
      case 'green':
        return { ...baseStyle, ...styles.greenSectionTitle };
      case 'orange':
        return { ...baseStyle, ...styles.orangeSectionTitle };
      case 'red':
        return { ...baseStyle, ...styles.redSectionTitle };
      case 'unavailable':
        return { ...baseStyle, ...styles.unavailableSectionTitle };
      default:
        return baseStyle;
    }
  };

  return (
    <View style={styles.performanceSectionContainer}>
      <Text style={getTitleStyle()}>{title}</Text>
      {acs.length > 0 ? (
        acs.map((ac, index) => (
          <ACWithAssembliesComponent key={ac.acId} ac={ac} />
        ))
      ) : (
        <View style={{ padding: 15, alignItems: 'center' }}>
          <Text style={{ fontSize: 10, color: '#6b7280' }}>
            No ACs in this performance zone
          </Text>
        </View>
      )}
    </View>
  );
};

/**
 * AC With Assemblies Component
 */
interface ACWithAssembliesComponentProps {
  ac: ACWithAssemblies;
}

const ACWithAssembliesComponent: React.FC<ACWithAssembliesComponentProps> = ({ ac }) => {
  return (
    <View>
      {/* AC Header */}
      <View style={styles.acHeaderContainer}>
        <Text style={styles.acHeaderText}>
          {ac.acName} - Zone {ac.zoneNumber} ({ac.zoneName})
        </Text>
        <Text style={styles.acSubHeaderText}>
          Total Assemblies: {ac.totalAssemblies} | Worked in: {ac.workedAssemblies}
        </Text>
      </View>
      
      {/* Assembly Table */}
      <View style={styles.acAssemblyTableContainer}>
        {/* Table Header */}
        <View style={{ ...styles.acAssemblyRow, backgroundColor: '#f3f4f6', fontWeight: 'bold' }}>
          <Text style={{ ...styles.tableCell, width: '24%' }}>Assembly</Text>
          <Text style={{ ...styles.tableCell, width: '13%' }}>Meetings</Text>
          <Text style={{ ...styles.tableCell, width: '13%' }}>Onboarded</Text>
          <Text style={{ ...styles.tableCell, width: '12%' }}>SLPs</Text>
          <Text style={{ ...styles.tableCell, width: '12%' }}>Forms</Text>
          <Text style={{ ...styles.tableCell, width: '12%' }}>Videos</Text>
          <Text style={{ ...styles.tableCell, width: '14%' }}>WA Groups</Text>
        </View>
        
        {/* Assembly Rows */}
        {ac.assemblies.map((assembly, index) => (
          <ACAssemblyRowComponent key={`${ac.acId}-${assembly.assembly}`} assembly={assembly} />
        ))}
      </View>
    </View>
  );
};

/**
 * AC Assembly Row Component
 */
interface ACAssemblyRowComponentProps {
  assembly: ACAssemblyRow;
}

const ACAssemblyRowComponent: React.FC<ACAssemblyRowComponentProps> = ({ assembly }) => {
  // Determine row background color
  const getRowStyle = () => {
    const baseStyle = styles.acAssemblyRow;
    switch (assembly.rowColor) {
      case 'high':
        return { ...baseStyle, ...styles.acAssemblyRowHigh };
      case 'moderate':
        return { ...baseStyle, ...styles.acAssemblyRowModerate };
      case 'poor':
        return { ...baseStyle, ...styles.acAssemblyRowPoor };
      case 'white':
      default:
        return { ...baseStyle, ...styles.acAssemblyRowWhite };
    }
  };

  return (
    <View style={getRowStyle()}>
      <Text style={{ ...styles.tableCell, width: '24%' }}>{assembly.assembly}</Text>
      <Text style={{ ...styles.tableCell, width: '13%' }}>{assembly.meetings}</Text>
      <Text style={{ ...styles.tableCell, width: '13%' }}>{assembly.onboarded}</Text>
      <Text style={{ ...styles.tableCell, width: '12%' }}>{assembly.slps}</Text>
      <Text style={{ ...styles.tableCell, width: '12%' }}>{assembly.forms}</Text>
      <Text style={{ ...styles.tableCell, width: '12%' }}>{assembly.videos}</Text>
      <Text style={{ ...styles.tableCell, width: '14%' }}>{assembly.waGroups}</Text>
    </View>
  );
};

// Chunked AC Performance Table to prevent memory issues
const ACTable = ({ zones }: { zones: ZoneData[] }) => {
  try {
    console.log('[ACTable] Processing zones for table generation:', {
      zonesLength: zones.length,
      zonesType: typeof zones,
      isArray: Array.isArray(zones)
    });

    const tableData = flattenDataForTable(zones);
    console.log('[ACTable] Flattened table data:', {
      length: tableData.length,
      type: typeof tableData,
      isArray: Array.isArray(tableData),
      firstFewRows: tableData.slice(0, 3).map(row => ({
        zone: row.zone,
        assembly: row.assembly,
        acName: row.acName,
        meetings: row.meetings
      })),
      lastFewRows: tableData.slice(-3).map(row => ({
        zone: row.zone,
        assembly: row.assembly,
        acName: row.acName,
        meetings: row.meetings
      }))
    });
    
    // Calculate unique real ACs (exclude phantom entries and deduplicate)
    const uniqueRealACs = new Set(
      tableData
        .filter(row => row.acId !== 'no-ac-assigned')
        .map(row => row.acId)
    ).size;
    
    const MAX_ROWS_PER_CHUNK = 15; // Smaller chunks for better rendering
    const chunks = [];
    
    // Split data into chunks if too large
    if (tableData.length > MAX_ROWS_PER_CHUNK) {
      console.log(`[ACTable] Large dataset (${tableData.length} rows). Splitting into chunks of ${MAX_ROWS_PER_CHUNK}.`);
      
      for (let i = 0; i < tableData.length; i += MAX_ROWS_PER_CHUNK) {
        const chunk = tableData.slice(i, i + MAX_ROWS_PER_CHUNK);
        chunks.push(chunk);
        console.log(`[ACTable] Chunk ${chunks.length}: ${chunk.length} rows, first AC: ${chunk[0]?.acName}`);
      }
    } else {
      chunks.push(tableData);
    }
    
    console.log('[ACTable] Rendering', chunks.length, 'table chunks with total', tableData.length, 'rows');
    
    return (
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>AC Performance Report</Text>
        
        {/* Single continuous table with all chunks rendered seamlessly */}
        <View style={styles.table}>
          <TableHeader />
          {chunks.map((chunk, chunkIndex) => 
            chunk.map((row, index) => {
              const globalIndex = chunkIndex * MAX_ROWS_PER_CHUNK + index;
              try {
                return (
                  <TableRow 
                    key={`row-${globalIndex}-${row.acId}`} 
                    data={row} 
                    index={globalIndex} 
                  />
                );
              } catch (rowError) {
                console.error(`[ACTable] ❌ Error rendering row ${globalIndex}:`, rowError);
                console.error('[ACTable] Row data:', JSON.stringify(row, null, 2));
                throw rowError;
              }
            })
          )}
        </View>
        
        <View style={styles.tableSummary}>
          <Text style={styles.summaryText}>Total ACs: {uniqueRealACs}</Text>
          <Text style={[styles.summaryText, { marginLeft: 20 }]}>Total Rows: {tableData.length}</Text>
          {chunks.length > 1 && (
            <Text style={[styles.summaryText, { marginLeft: 20 }]}>Sections: {chunks.length}</Text>
          )}
        </View>
      </View>
    );
  } catch (error) {
    console.error('=== ACTABLE ERROR ===');
    console.error('[ACTable] ❌ Error in ACTable component:', error);
    console.error('[ACTable] Zones data causing error:', JSON.stringify(zones, null, 2));
    throw error;
  }
};

// Summary Statistics Component
const SummaryStatistics: React.FC<{ zones: ZoneData[] }> = ({ zones }) => {
  // Calculate totals from zones
  let totalMeetings = 0;
  let totalOnboarded = 0;
  let totalSLPs = 0;
  let totalForms = 0;
  let totalVideos = 0;
  let totalWAGroups = 0;
  let totalACs = 0;
  
  zones.forEach(zone => {
    zone.assemblies.forEach(assembly => {
      assembly.acs.forEach(ac => {
        if (ac.id !== 'no-ac-assigned') {
          totalACs++;
          totalMeetings += ac.metrics.meetings || 0;
          totalOnboarded += ac.metrics.volunteers || 0;
          totalSLPs += ac.metrics.slps || 0;
          totalForms += ac.metrics.forms || 0;
          totalVideos += ac.metrics.videos || 0;
          totalWAGroups += (ac.metrics.assemblyWaGroups || 0) + (ac.metrics.centralWaGroups || 0);
        }
      });
    });
  });
  
  return (
    <View style={styles.summaryBox}>
      <Text style={styles.summaryTitle}>Summary Statistics</Text>
      <View style={styles.metricsGrid}>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total Meetings</Text>
          <Text style={styles.metricValue}>{totalMeetings}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total Onboarded</Text>
          <Text style={styles.metricValue}>{totalOnboarded}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total SLPs</Text>
          <Text style={styles.metricValue}>{totalSLPs}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total Forms</Text>
          <Text style={styles.metricValue}>{totalForms}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total Videos</Text>
          <Text style={styles.metricValue}>{totalVideos}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total WA Groups</Text>
          <Text style={styles.metricValue}>{totalWAGroups}</Text>
        </View>
      </View>
    </View>
  );
};

// Detailed Activities Component (if included)
const DetailedActivitiesSection: React.FC<{ activities: DetailedActivity[] }> = ({ activities }) => {
  if (!activities || activities.length === 0) return null;
  
  return (
    <View style={styles.indentLevel1}>
      <Text style={styles.subsectionTitle}>Recent Activities (Sample)</Text>
      {activities.slice(0, 5).map((activity, idx) => (
        <View key={idx} style={styles.activityItem}>
          <Text style={styles.boldText}>{activity.type} - {activity.coordinatorName}</Text>
          <Text>Assembly: {activity.assembly}</Text>
          <Text>Date: {activity.date}</Text>
          {activity.description && <Text>{activity.description}</Text>}
        </View>
      ))}
    </View>
  );
};

// Zone-wise Summary Component with corrected AC counting
const ZoneWiseSummary = ({ zones }: { zones: ZoneData[] }) => {
  // Calculate corrected metrics for each zone
  const zoneMetrics = zones.map(zone => {
    // Get unique real AC IDs (exclude phantom entries)
    const uniqueACs = new Set<string>();
    let activeCount = 0;
    
    zone.assemblies.forEach(assembly => {
      assembly.acs.forEach(ac => {
        if (ac.id !== 'no-ac-assigned') {
          uniqueACs.add(ac.id);
          // Count as active if meetings >= 7
          if (Number(ac.metrics.meetings) >= 7) {
            activeCount++;
          }
        }
      });
    });
    
    return {
      name: zone.name,
      totalAssemblies: zone.totalAssemblies,
      totalACs: uniqueACs.size, // Deduplicated count
      activeACs: activeCount
    };
  });
  
  return (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>Zone-wise Overview</Text>
      <View style={styles.summaryTable}>
        <View style={styles.summaryHeader}>
          <Text style={styles.summaryHeaderText}>Zone</Text>
          <Text style={styles.summaryHeaderText}>Assemblies</Text>
          <Text style={styles.summaryHeaderText}>Total ACs</Text>
          <Text style={styles.summaryHeaderText}>Active ACs</Text>
        </View>
        {zoneMetrics.map((zone, index) => (
          <View key={index} style={styles.summaryRow}>
            <Text style={styles.summaryCell}>{zone.name}</Text>
            <Text style={styles.summaryCell}>{zone.totalAssemblies}</Text>
            <Text style={styles.summaryCell}>{zone.totalACs}</Text>
            <Text style={styles.summaryCell}>{zone.activeACs}</Text>
          </View>
        ))}
      </View>
    </View>
  );
};

// Executive Summary Component
const ExecutiveSummarySection: React.FC<{ summary: ExecutiveSummary }> = ({ summary }) => (
  <View>
    <Text style={styles.subtitle}>Executive Summary</Text>
    <View style={styles.row}>
      <View style={styles.column}>
        <Text style={styles.boldText}>Total Zones: {summary.totalZones}</Text>
        <Text style={styles.boldText}>Total Assemblies: {summary.totalAssemblies}</Text>
      </View>
      <View style={styles.column}>
        <Text style={styles.boldText}>Total ACs: {summary.totalACs}</Text>
        <Text style={styles.boldText}>Total SLPs: {summary.totalSLPs}</Text>
      </View>
    </View>
    <View style={styles.row}>
      <View style={styles.column}>
        <Text style={styles.text}>Active ACs: {summary.activeACs}</Text>
        <Text style={styles.text}>Active SLPs: {summary.activeSLPs}</Text>
      </View>
      <View style={styles.column}>
        <Text style={styles.text}>High Performance: {summary.performanceSummary.high} ACs</Text>
        <Text style={styles.text}>Moderate: {summary.performanceSummary.moderate} ACs</Text>
        <Text style={styles.text}>Needs Attention: {summary.performanceSummary.poor} ACs</Text>
      </View>
    </View>
    <View style={styles.metricsGrid}>
      {summary.keyMetrics.map((metric: ReportMetric, idx: number) => (
        <View key={idx} style={styles.metricBox}>
          <Text style={styles.metricLabel}>{metric.name}</Text>
          <Text style={styles.metricValue}>{metric.value}</Text>
        </View>
      ))}
    </View>
  </View>
);

// Error Boundary Wrapper Component
const SafeComponent: React.FC<{ children: React.ReactNode; componentName: string; data?: any }> = ({ children, componentName, data }) => {
  try {
    console.log(`[SafeComponent] Rendering ${componentName}`);
    return <>{children}</>;
  } catch (error) {
    console.error(`=== ERROR in ${componentName} ===`);
    console.error(`[SafeComponent] ❌ Error in ${componentName}:`, error);
    if (data) {
      console.error(`[SafeComponent] Data causing error in ${componentName}:`, JSON.stringify(data, null, 2));
    }
    throw error; // Re-throw to trigger main error handler
  }
};

// Main PDF Document Component - Table Based Layout
const PDFReport: React.FC<PDFReportProps> = ({ data }) => {
  try {
    console.log('[PDFReport] Starting PDF component render');
    
    return (
      <Document>
        <Page size="A4" style={styles.page} orientation="landscape">
          <SafeComponent componentName="ReportHeader" data={data.header}>
            <ReportHeader data={data} />
          </SafeComponent>
          
          {/* Executive Summary */}
          <SafeComponent componentName="ExecutiveSummarySection" data={data.summary}>
            <ExecutiveSummarySection summary={data.summary} />
          </SafeComponent>
          
          {/* Zone-wise Summary if zones exist */}
          {data.zones && data.zones.length > 0 && (
            <SafeComponent componentName="ZoneWiseSummary" data={data.zones}>
              <ZoneWiseSummary zones={data.zones} />
            </SafeComponent>
          )}
          
          {/* Summary Statistics */}
          {data.zones && data.zones.length > 0 && (
            <SafeComponent componentName="SummaryStatistics" data={data.zones}>
              <SummaryStatistics zones={data.zones} />
            </SafeComponent>
          )}
          
          {/* New AC Performance Report Section - AC-wise Layout */}
          {data.acPerformanceSections ? (
            <SafeComponent componentName="ACPerformanceSection" data={data.acPerformanceSections}>
              <ACPerformanceSection sections={data.acPerformanceSections} />
            </SafeComponent>
          ) : data.zones && data.zones.length > 0 ? (
            <SafeComponent componentName="ACTable" data={data.zones}>
              <ACTable zones={data.zones} />
            </SafeComponent>
          ) : (
            <View style={{ padding: 20 }}>
              <Text style={styles.text}>No zone data available for report generation.</Text>
            </View>
          )}
          
          {/* Footer */}
          <SafeComponent componentName="Footer" data={data.header}>
            <Text style={[styles.footer, { fontSize: 7 }]}>
              Bihar Congress Dashboard - {data.header.title} | Generated: {new Date(data.header.generatedAt).toLocaleDateString()}
            </Text>
          </SafeComponent>
        </Page>
      </Document>
    );
  } catch (renderError) {
    console.error('=== PDF COMPONENT RENDER ERROR ===');
    console.error('[PDFReport] ❌ Error during component render:', renderError);
    console.error('[PDFReport] Complete data structure causing error:', JSON.stringify(data, null, 2));
    throw renderError;
  }
};

/**
 * Generate PDF blob from report data
 */
export async function generatePDFBlob(data: ReportData): Promise<Blob> {
  console.log('[generatePDFBlob] Starting PDF generation for:', data.header.title);
  
  try {
    // Calculate data sizes for analysis
    const totalAssemblies = data.zones.reduce((sum, zone) => sum + zone.assemblies.length, 0);
    const totalACs = data.zones.reduce((sum, zone) => 
      sum + zone.assemblies.reduce((acSum, assembly) => acSum + assembly.acs.length, 0), 0);
    
    console.log('[generatePDFBlob] 📊 DATA SIZE ANALYSIS:', {
      zones: data.zones.length,
      totalAssemblies,
      totalACs,
      keyMetrics: data.summary?.keyMetrics?.length || 0,
      estimatedTableRows: totalACs,
      dataStringSize: JSON.stringify(data).length,
      exceedsRecommendedSize: totalACs > 50 ? '⚠️  YES - May cause memory issues' : '✅ Within limits'
    });
    
    // Warn if data size is large
    if (totalACs > 100) {
      console.warn('⚠️  [generatePDFBlob] LARGE DATASET WARNING: ' + totalACs + ' ACs may exceed PDF rendering limits');
    }
    
    console.log('[generatePDFBlob] Attempting PDF generation...');
    const blob = await pdf(<PDFReport data={data} />).toBlob();
    console.log('[generatePDFBlob] ✅ PDF generated successfully, size:', blob.size);
    return blob;
  } catch (error) {
    console.error('=== PDF GENERATION ERROR CAUGHT ===');
    console.error('[generatePDFBlob] ❌ Error Type:', error instanceof Error ? error.name : 'Unknown');
    console.error('[generatePDFBlob] ❌ Error Message:', error instanceof Error ? error.message : String(error));
    
    // Check if it's an array length error
    if (error instanceof Error && error.message.includes('Invalid array length')) {
      const totalACs = data.zones.reduce((sum, zone) => 
        sum + zone.assemblies.reduce((acSum, assembly) => acSum + assembly.acs.length, 0), 0);
      
      console.error('=== ARRAY LENGTH ERROR - SIZE ANALYSIS ===');
      console.error('[generatePDFBlob] ❌ LIKELY CAUSE: Dataset too large for PDF rendering');
      console.error('[generatePDFBlob] Total ACs attempting to render:', totalACs);
      console.error('[generatePDFBlob] Total data size (bytes):', JSON.stringify(data).length);
      console.error('[generatePDFBlob] Recommendation: Implement data chunking or filtering');
      console.error('=== SOLUTION: Reduce data size or implement pagination ===');
    }
    
    throw error;
  }
}

/**
 * Generate and download PDF report
 */
export async function generateAndDownloadPDF(data: ReportData): Promise<void> {
  console.log('[generateAndDownloadPDF] Starting PDF generation and download');
  
  try {
    const blob = await generatePDFBlob(data);
    
    // Create download link
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    
    // Generate filename
    const timestamp = new Date().toISOString().slice(0, 10);
    const vertical = data.header.vertical === 'shakti-abhiyaan' ? 'ShaktiAbhiyaan' : 'WTMSLP';
    const dateRange = `${data.header.dateRange.startDate}_to_${data.header.dateRange.endDate}`.replace(/\//g, '-');
    link.download = `${vertical}_Report_${dateRange}_${timestamp}.pdf`;
    
    // Trigger download
    document.body.appendChild(link);
    link.click();
    
    // Cleanup
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    console.log('[generateAndDownloadPDF] PDF download initiated successfully');
  } catch (error) {
    console.error('[generateAndDownloadPDF] Error during PDF generation/download:', error);
    throw error;
  }
}
