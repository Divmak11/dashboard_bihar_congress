import React from 'react';
import { Document, Page, Text, View, Font, PDFDownloadLink, pdf } from '@react-pdf/renderer';
import { 
  ReportData, 
  ACPerformance, 
  AssemblyData, 
  ZoneData, 
  DetailedActivity, 
  ExecutiveSummary,
  ReportMetric 
} from '../../models/reportTypes';
import { 
  PDF_STYLES, 
  FONT_CONFIG, 
  FILE_NAME_CONFIG,
  getPerformanceLevel,
  getPerformanceColor 
} from '../config/pdfConfig';

// Register custom fonts for Devanagari support
Font.register({
  family: FONT_CONFIG.family,
  fonts: [
    { src: FONT_CONFIG.sources.regular, fontWeight: 'normal' },
    { src: FONT_CONFIG.sources.bold, fontWeight: 'bold' },
  ],
});

// Performance color scheme is now imported from config

// PDF Styles
const styles = PDF_STYLES;

interface PDFReportProps {
  data: ReportData;
}

// Header Component
const ReportHeader: React.FC<{ data: ReportData }> = ({ data }) => (
  <View>
    <Text style={styles.title}>{data.header.title}</Text>
    <View style={styles.headerInfo}>
      <View style={{ flex: 1 }}>
        <Text style={styles.headerItem}>Generated: {new Date(data.header.generatedAt).toLocaleDateString()}</Text>
        <Text style={styles.headerItem}>Period: {data.header.dateRange.startDate} to {data.header.dateRange.endDate}</Text>
      </View>
      <View style={{ flex: 1 }}>
        <Text style={styles.headerItem}>Vertical: {data.header.vertical === 'shakti-abhiyaan' ? 'Shakti Abhiyaan' : 'WTM-SLP'}</Text>
        <Text style={styles.headerItem}>Generated By: {data.header.generatedBy}</Text>
      </View>
    </View>
  </View>
);

// Interface for flattened AC data
interface FlattenedACData {
  zoneIndex: number;
  zone: string;
  zonalIncharge: string;
  assembly: string;
  acName: string;
  acId: string;
  meetings: number;
  onboarded: number;
  slps: number;
  forms: number;
  videos: number;
  waGroups: number;
  performanceLevel: string;
}

// Function to flatten hierarchical data into table format
const flattenDataForTable = (zones: ZoneData[]): FlattenedACData[] => {
  const tableData: FlattenedACData[] = [];
  
  // Sort zones by extracting zone number
  const sortedZones = [...zones].sort((a, b) => {
    const getZoneNumber = (name: string) => {
      const match = name.match(/Zone\s+(\d+)/i);
      return match ? parseInt(match[1]) : 999;
    };
    return getZoneNumber(a.name) - getZoneNumber(b.name);
  });
  
  sortedZones.forEach((zone, zoneIndex) => {
    zone.assemblies.forEach(assembly => {
      assembly.acs.forEach(ac => {
        // Include phantom assemblies (no-ac-assigned) in the table
        tableData.push({
          zoneIndex: zoneIndex + 1, // Store zone index for display
          zone: zone.name,
          zonalIncharge: zone.inchargeName || 'N/A',
          assembly: assembly.name,
          acName: ac.id === 'no-ac-assigned' ? 'No AC Assigned' : ac.name,
          acId: ac.id, // Store AC ID for deduplication
          meetings: ac.metrics.meetings || 0,
          onboarded: ac.metrics.volunteers || 0,
          slps: ac.metrics.leaders || 0,
          forms: ac.metrics.forms || 0,
          videos: ac.metrics.videos || 0,
          waGroups: (ac.metrics.assemblyWaGroups || 0) + (ac.metrics.centralWaGroups || 0),
          performanceLevel: ac.id === 'no-ac-assigned' ? 'poor' : ac.performanceLevel
        });
      });
    });
  });
  
  return tableData;
};

// Table Header Component
const TableHeader = () => (
  <View style={styles.tableHeaderRow}>
    <Text style={[styles.tableHeaderCell, { flex: 0.8 }]}>Zone</Text>
    <Text style={[styles.tableHeaderCell, { flex: 1.5 }]}>Zonal Incharge</Text>
    <Text style={[styles.tableHeaderCell, { flex: 1.5 }]}>Assembly</Text>
    <Text style={[styles.tableHeaderCell, { flex: 1.5 }]}>AC Name</Text>
    <Text style={styles.tableHeaderCell}>Meetings</Text>
    <Text style={styles.tableHeaderCell}>Onboarded</Text>
    <Text style={styles.tableHeaderCell}>SLPs</Text>
    <Text style={styles.tableHeaderCell}>Forms</Text>
    <Text style={styles.tableHeaderCell}>Videos</Text>
    <Text style={styles.tableHeaderCell}>WA Groups</Text>
  </View>
);

// Table Row Component with performance-based color coding
const TableRow = ({ data, index }: { data: FlattenedACData; index: number }) => {
  // Determine row style based on performance level
  const getRowStyle = () => {
    if (data.acId === 'no-ac-assigned') {
      // Phantom assemblies get neutral styling
      return [styles.tableRow, { backgroundColor: index % 2 === 0 ? '#ffffff' : '#f9fafb' }];
    }
    
    // Apply performance-based color coding
    const meetings = Number(data.meetings) || 0;
    if (meetings >= 7) {
      return [styles.tableRowHigh];
    } else if (meetings >= 5) {
      return [styles.tableRowModerate];
    } else {
      return [styles.tableRowPoor];
    }
  };
  
  // Determine cell style for metrics (highlight if > 0)
  const getMetricCellStyle = (value: any) => {
    const numValue = Number(value) || 0;
    if (data.acId === 'no-ac-assigned') {
      return styles.tableCellDim;
    }
    return numValue > 0 ? styles.tableCellHighlight : styles.tableCell;
  };
  
  return (
    <View style={getRowStyle()}>
      <Text style={[styles.tableCell, { flex: 0.8 }]}>Zone - {data.zoneIndex}</Text>
      <Text style={[styles.tableCell, { flex: 1.5 }]}>{data.zonalIncharge}</Text>
      <Text style={[styles.tableCell, { flex: 1.5 }]}>{data.assembly}</Text>
      <Text style={[styles.tableCell, { flex: 1.5 }]}>{data.acName}</Text>
      <Text style={getMetricCellStyle(data.meetings)}>{data.meetings}</Text>
      <Text style={getMetricCellStyle(data.onboarded)}>{data.onboarded}</Text>
      <Text style={getMetricCellStyle(data.slps)}>{data.slps}</Text>
      <Text style={getMetricCellStyle(data.forms)}>{data.forms}</Text>
      <Text style={getMetricCellStyle(data.videos)}>{data.videos}</Text>
      <Text style={getMetricCellStyle(data.waGroups)}>{data.waGroups}</Text>
    </View>
  );
};

// Main AC Performance Table
const ACTable = ({ zones }: { zones: ZoneData[] }) => {
  const tableData = flattenDataForTable(zones);
  
  // Calculate unique real ACs (exclude phantom entries and deduplicate)
  const uniqueRealACs = new Set(
    tableData
      .filter(row => row.acId !== 'no-ac-assigned')
      .map(row => row.acId)
  ).size;
  
  return (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>AC Performance Report</Text>
      <View style={styles.table}>
        <TableHeader />
        {tableData.map((row, index) => (
          <TableRow key={index} data={row} index={index} />
        ))}
      </View>
      <View style={styles.tableSummary}>
        <Text style={styles.summaryText}>Total ACs: {uniqueRealACs}</Text>
        <Text style={[styles.summaryText, { marginLeft: 20 }]}>Total Rows: {tableData.length}</Text>
      </View>
    </View>
  );
};

// Summary Statistics Component
const SummaryStatistics: React.FC<{ zones: ZoneData[] }> = ({ zones }) => {
  // Calculate totals from zones
  let totalMeetings = 0;
  let totalOnboarded = 0;
  let totalSLPs = 0;
  let totalForms = 0;
  let totalVideos = 0;
  let totalWAGroups = 0;
  let totalACs = 0;
  
  zones.forEach(zone => {
    zone.assemblies.forEach(assembly => {
      assembly.acs.forEach(ac => {
        if (ac.id !== 'no-ac-assigned') {
          totalACs++;
          totalMeetings += ac.metrics.meetings || 0;
          totalOnboarded += ac.metrics.volunteers || 0;
          totalSLPs += ac.metrics.slps || 0;
          totalForms += ac.metrics.forms || 0;
          totalVideos += ac.metrics.videos || 0;
          totalWAGroups += (ac.metrics.assemblyWaGroups || 0) + (ac.metrics.centralWaGroups || 0);
        }
      });
    });
  });
  
  return (
    <View style={styles.summaryBox}>
      <Text style={styles.summaryTitle}>Summary Statistics</Text>
      <View style={styles.metricsGrid}>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total ACs</Text>
          <Text style={styles.metricValue}>{totalACs}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total Meetings</Text>
          <Text style={styles.metricValue}>{totalMeetings}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total Onboarded</Text>
          <Text style={styles.metricValue}>{totalOnboarded}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total SLPs</Text>
          <Text style={styles.metricValue}>{totalSLPs}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total Forms</Text>
          <Text style={styles.metricValue}>{totalForms}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total Videos</Text>
          <Text style={styles.metricValue}>{totalVideos}</Text>
        </View>
        <View style={styles.metricBox}>
          <Text style={styles.metricLabel}>Total WA Groups</Text>
          <Text style={styles.metricValue}>{totalWAGroups}</Text>
        </View>
      </View>
    </View>
  );
};

// Detailed Activities Component (if included)
const DetailedActivitiesSection: React.FC<{ activities: DetailedActivity[] }> = ({ activities }) => {
  if (!activities || activities.length === 0) return null;
  
  return (
    <View style={styles.indentLevel1}>
      <Text style={styles.subsectionTitle}>Recent Activities (Sample)</Text>
      {activities.slice(0, 5).map((activity, idx) => (
        <View key={idx} style={styles.activityItem}>
          <Text style={styles.boldText}>{activity.type} - {activity.coordinatorName}</Text>
          <Text>Assembly: {activity.assembly}</Text>
          <Text>Date: {activity.date}</Text>
          {activity.description && <Text>{activity.description}</Text>}
        </View>
      ))}
    </View>
  );
};

// Zone-wise Summary Component with corrected AC counting
const ZoneWiseSummary = ({ zones }: { zones: ZoneData[] }) => {
  // Calculate corrected metrics for each zone
  const zoneMetrics = zones.map(zone => {
    // Get unique real AC IDs (exclude phantom entries)
    const uniqueACs = new Set<string>();
    let activeCount = 0;
    
    zone.assemblies.forEach(assembly => {
      assembly.acs.forEach(ac => {
        if (ac.id !== 'no-ac-assigned') {
          uniqueACs.add(ac.id);
          // Count as active if meetings >= 7
          if (Number(ac.metrics.meetings) >= 7) {
            activeCount++;
          }
        }
      });
    });
    
    return {
      name: zone.name,
      totalAssemblies: zone.totalAssemblies,
      totalACs: uniqueACs.size, // Deduplicated count
      activeACs: activeCount
    };
  });
  
  return (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>Zone-wise Overview</Text>
      <View style={styles.summaryTable}>
        <View style={styles.summaryHeader}>
          <Text style={styles.summaryHeaderText}>Zone</Text>
          <Text style={styles.summaryHeaderText}>Assemblies</Text>
          <Text style={styles.summaryHeaderText}>Total ACs</Text>
          <Text style={styles.summaryHeaderText}>Active ACs</Text>
        </View>
        {zoneMetrics.map((zone, index) => (
          <View key={index} style={styles.summaryRow}>
            <Text style={styles.summaryCell}>{zone.name}</Text>
            <Text style={styles.summaryCell}>{zone.totalAssemblies}</Text>
            <Text style={styles.summaryCell}>{zone.totalACs}</Text>
            <Text style={styles.summaryCell}>{zone.activeACs}</Text>
          </View>
        ))}
      </View>
    </View>
  );
};

// Executive Summary Component
const ExecutiveSummarySection: React.FC<{ summary: ExecutiveSummary }> = ({ summary }) => (
  <View>
    <Text style={styles.subtitle}>Executive Summary</Text>
    <View style={styles.row}>
      <View style={styles.column}>
        <Text style={styles.boldText}>Total Zones: {summary.totalZones}</Text>
        <Text style={styles.boldText}>Total Assemblies: {summary.totalAssemblies}</Text>
      </View>
      <View style={styles.column}>
        <Text style={styles.boldText}>Total ACs: {summary.totalACs}</Text>
        <Text style={styles.boldText}>Total SLPs: {summary.totalSLPs}</Text>
      </View>
    </View>
    <View style={styles.row}>
      <View style={styles.column}>
        <Text style={styles.text}>Active ACs: {summary.activeACs}</Text>
        <Text style={styles.text}>Active SLPs: {summary.activeSLPs}</Text>
      </View>
      <View style={styles.column}>
        <Text style={styles.text}>High Performance: {summary.performanceSummary.high} ACs</Text>
        <Text style={styles.text}>Moderate: {summary.performanceSummary.moderate} ACs</Text>
        <Text style={styles.text}>Needs Attention: {summary.performanceSummary.poor} ACs</Text>
      </View>
    </View>
    <View style={styles.metricsGrid}>
      {summary.keyMetrics.map((metric: ReportMetric, idx: number) => (
        <View key={idx} style={styles.metricBox}>
          <Text style={styles.metricLabel}>{metric.name}</Text>
          <Text style={styles.metricValue}>{metric.value}</Text>
        </View>
      ))}
    </View>
  </View>
);

// Main PDF Document Component - Table Based Layout
const PDFReport: React.FC<PDFReportProps> = ({ data }) => (
  <Document>
    <Page size="A4" style={styles.page} orientation="landscape">
      <ReportHeader data={data} />
      
      {/* Executive Summary */}
      <ExecutiveSummarySection summary={data.summary} />
      
      {/* Zone-wise Summary if zones exist */}
      {data.zones && data.zones.length > 0 && (
        <ZoneWiseSummary zones={data.zones} />
      )}
      
      {/* Summary Statistics */}
      {data.zones && data.zones.length > 0 && (
        <SummaryStatistics zones={data.zones} />
      )}
      
      {/* Main AC Performance Table */}
      {data.zones && data.zones.length > 0 ? (
        <ACTable zones={data.zones} />
      ) : (
        <View style={{ padding: 20 }}>
          <Text style={styles.text}>No zone data available for report generation.</Text>
        </View>
      )}
      
      {/* Footer */}
      <Text style={[styles.footer, { fontSize: 7 }]}>
        Bihar Congress Dashboard - {data.header.title} | Generated: {new Date(data.header.generatedAt).toLocaleDateString()}
      </Text>
    </Page>
  </Document>
);

/**
 * Generate PDF blob from report data
 */
export async function generatePDFBlob(data: ReportData): Promise<Blob> {
  console.log('[generatePDFBlob] Starting PDF generation for:', data.header.title);
  
  try {
    const blob = await pdf(<PDFReport data={data} />).toBlob();
    console.log('[generatePDFBlob] PDF generated successfully, size:', blob.size);
    return blob;
  } catch (error) {
    console.error('[generatePDFBlob] Error generating PDF:', error);
    throw error;
  }
}

/**
 * Generate and download PDF report
 */
export async function generateAndDownloadPDF(data: ReportData): Promise<void> {
  console.log('[generateAndDownloadPDF] Starting PDF generation and download');
  
  try {
    const blob = await generatePDFBlob(data);
    
    // Create download link
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    
    // Generate filename
    const timestamp = new Date().toISOString().slice(0, 10);
    const vertical = data.header.vertical === 'shakti-abhiyaan' ? 'ShaktiAbhiyaan' : 'WTMSLP';
    const dateRange = `${data.header.dateRange.startDate}_to_${data.header.dateRange.endDate}`.replace(/\//g, '-');
    link.download = `${vertical}_Report_${dateRange}_${timestamp}.pdf`;
    
    // Trigger download
    document.body.appendChild(link);
    link.click();
    
    // Cleanup
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    console.log('[generateAndDownloadPDF] PDF download initiated successfully');
  } catch (error) {
    console.error('[generateAndDownloadPDF] Error during PDF generation/download:', error);
    throw error;
  }
}
